package main.java.db;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.measures.Metric;

import main.java.components.IComponent;
import main.java.components.MethodComponent;

/**
 * Client to access the SonarQube H2 database
 * @author Tomas Lestyan
 */
public class SonarDbClient {

	/** The logger object */
	private final Logger log = LoggerFactory.getLogger(this.getClass());
	private static final int DEFAULT_TIMEOUT = 1000;
	private static final String DB_URL = "jdbc:h2:tcp://localhost:9092/sonar";
	private static final String JDBC_H2_DRIVER = "org.h2.Driver";
	private Connection connection;

	/**
	 * Constructor
	 */
	public SonarDbClient(boolean connect) {
		if (connect) {
			connect();
		}
	}

	public void connect() {
		try {
			Class.forName(JDBC_H2_DRIVER);
			connection = DriverManager.getConnection(DB_URL);
		} catch (ClassNotFoundException | SQLException e) {
			// could not create connection
			connection = null;
			log.warn("Connection with SonarQube database not established", e);
		}
	}

	public void disconnect() {
		try {
			if (connection != null) {
				connection.close();
			}
		} catch (SQLException e) {
			log.warn("Can't close the connection", e);
		}
	}

	public boolean isConnected() {
		try {
			return ((connection != null) && connection.isValid(1000));
		} catch (SQLException e) {
			log.warn("Connection with SonarQube database not established", e);
			return false;
		}
	}


	public boolean createTables() {
		try {
			// check connection
			if (!isConnectionValid()) return false;
			Statement st = connection.createStatement();
			st.executeUpdate("CREATE TABLE IF NOT EXISTS Components (id varchar(255) NOT NULL, ProjectsKEE varchar(255) NOT NULL, type varchar(255) NOT NULL, startLine int, endLine int, PRIMARY KEY (id)); "
					//			st.executeUpdate("CREATE TABLE IF NOT EXISTS Components (id varchar(255) NOT NULL, ProjectsKEE varchar(255) NOT NULL REFERENCES Projects (KEE), startLine int, endLine int, PRIMARY KEY (id)); "
					+ "CREATE TABLE IF NOT EXISTS Measures (id int GENERATED BY DEFAULT AS IDENTITY, Metricsid varchar(255) NOT NULL  REFERENCES Metrics (id), Componentsid varchar(255) NOT NULL  REFERENCES Metrics (name), value int, PRIMARY KEY (id)); "
					+ "CREATE TABLE IF NOT EXISTS RecentMeasures (id int GENERATED BY DEFAULT AS IDENTITY, value int, Componentsid varchar(255) NOT NULL  REFERENCES Components (id), Metricsid varchar(255) NOT NULL  REFERENCES Metrics (name), PRIMARY KEY (id));");
			st.close();
		} catch (SQLException e) {
			log.warn("Can't create the metrics and records table", e);
			return false;
		}
		return true;
	}

	public void saveComponent(String id, String sonarComponentID, String type, int startLine, int endLine) {
		try {
			// check connection
			if (!isConnectionValid()) {
				return;
			}
			Statement st = connection.createStatement();
			st.executeUpdate(String.format("MERGE INTO Components (id , ProjectsKEE , type, startLine, endLine) VALUES ('%s', '%s', '%s', %s, %s)", id, sonarComponentID, type,  startLine, endLine));
			st.close();
		} catch (SQLException e) {
			log.warn("Can't save the value of component: " + id, e);
		}
	}

	public void saveMeasure(Metric<? extends Serializable> metric, String componentID, int value) {
		try {
			// check connection
			if (!isConnectionValid()) {
				return;
			}
			Statement st = connection.createStatement();
			st.executeUpdate(String.format("INSERT INTO RecentMeasures (value , Componentsid, Metricsid) VALUES (%s, '%s', '%s')", value, componentID, metric.getName()));
			st.close();
		} catch (SQLException e) {
			log.warn("Can't save the measurement for metric: " + metric.getKey(), e);
		}
	}

	public Collection<IComponent> getComponents() {
		try {
			// check connection
			if (!isConnectionValid()) {
				return null;
			}
			Collection<IComponent> components = new HashSet<>();
			Statement st = connection.createStatement();
			ResultSet queryResult = st.executeQuery("SELECT * FROM Components");
			queryResult.next();
			while (queryResult.next()) {
				if (queryResult.getString("TYPE").equalsIgnoreCase("method")) {
					String id = queryResult.getString("ID");
					String sonarKey = queryResult.getString("PROJECTSKEE");
					int start = queryResult.getInt("STARTLINE");
					int end = queryResult.getInt("ENDLINE");
					Map<Object, Object> measures = getMeasures(id);
					components.add(new MethodComponent(id, sonarKey, "", null));
					queryResult.next();
				}
			}
			return components;
		} catch (SQLException e) {
			log.warn("Can't retrieve components", e);
		}
		return null;
	}

	private Map<Object, Object> getMeasures(String id) {
		try {
			// check connection
			if (!isConnectionValid()) {
				return null;
			}
			Map<Object, Object> measures = new HashMap<>();
			Statement st = connection.createStatement();
			ResultSet queryResult = st.executeQuery(String.format("SELECT * FROM RecentMeasures WHERE Componentsid = '%s' ", id));
			while (queryResult.next()) {
				String metric = queryResult.getString("Metricsid");
				int value = queryResult.getInt("value");
				measures.put(metric, Integer.valueOf(value));
			}
			return measures;
		} catch (SQLException e) {
			log.warn("Can't retrieve components", e);
		}
		return null;
	}

	private boolean isConnectionValid() throws SQLException {
		return connection != null && connection.isValid(DEFAULT_TIMEOUT);
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#finalize()
	 */
	@Override
	protected void finalize() throws Throwable {
		disconnect();
		super.finalize();
	}
}
